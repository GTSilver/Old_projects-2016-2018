unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, OpenGL, ExtCtrls, Menus, StdCtrls, Spin;

type
  TForm1 = class(TForm)
    procedure FormCreate(Sender: TObject);
    procedure FormPaint(Sender: TObject);
    procedure FormResize(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;
  HRC : HGLRC ;
  angle: single;
  Dist: real;
  W : integer;
implementation

uses Unit2;

{$R *.dfm}

procedure SetDCPixelFormat ( hdc : HDC );
 var
  pfd : TPixelFormatDescriptor;
  nPixelFormat : Integer;
 begin
  FillChar (pfd, SizeOf (pfd), 0);
  pfd.dwFlags  := PFD_DRAW_TO_WINDOW or PFD_SUPPORT_OPENGL or PFD_DOUBLEBUFFER;
   nPixelFormat := ChoosePixelFormat (hdc, @pfd);
  SetPixelFormat (hdc, nPixelFormat, @pfd);
 end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  SetDCPixelFormat(Canvas.Handle);
  hrc := wglCreateContext(Canvas.Handle);
  wglMakeCurrent(Canvas.Handle, hrc);
  glEnable(GL_DEPTH_TEST); // включаем проверку разрешения фигур (впереди стоящая закрывает фигуру за ней)
  glDepthFunc(GL_LEQUAL);  //тип проверки
end;

procedure TForm1.FormPaint(Sender: TObject);
begin

  if (form2.SpinEdit1.Text = '') then form2.SpinEdit1.Value := 0; //устранение ошибки пустоты
  if (form2.SpinEdit2.Text = '') then form2.SpinEdit2.Value := 0; //устранение ошибки пустоты

  Dist := form2.SpinEdit2.Value;
  if Dist < 0 then form2.SpinEdit2.Value :=0;

  if(Form1.Height > Form1.Width) OR (Form1.Height < Form1.Width)  //Сохранение пропорций
  then
  Form1.Width := Form1.Height;

  Form2.Show;                             //Отображение настроек
  Form2.Height := Form1.Height;           //Привязка высоты двух форм
  form2.Width := 376;                     //фиксация ширины окна настроек
  Form2.Top := Form1.Top;                 //Привязка форм по вертикальной границе
  Form2.Left := Form1.Left + Form1.Width; //Привязка форм по горизонтальной границе

  angle:=form2.SpinEdit1.Value;

  FormResize(Sender); //процедура обновления

  if GetAsyncKeyState(VK_LEFT)<>0 then angle:=angle+0.5;
  if GetAsyncKeyState(VK_RIGHT)<>0 then angle:=angle-0.5;

  glRotatef(angle,0,0,1);

 glClearColor (0.5, 0.5, 0.75, 1.0); // цвет фона
 glClear (GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT); // очистка буфера цвета

glBegin(GL_LINES); //рисуем линию
glColor3f(0.6,0,0); {раскрасим первую вершину}    glVertex3f(1000,0,0); //позиция первой вершины
glColor3f(0.6,0,0); {раскрасим вторую вершину}    glVertex3f(-1000,0,0); //позиция второй вершины
glEnd;

glBegin(GL_LINES); //рисуем линию
glColor3f(0.6,0.6,0); {раскрасим первую вершину}    glVertex3f(0,1000,0); //позиция первой вершины
glColor3f(0.6,0.5,0); {раскрасим вторую вершину}    glVertex3f(0,-1000,0); //позиция второй вершины
glEnd;

glBegin(GL_LINES); //рисуем линию
glColor3f(0,0,0.6); {раскрасим первую вершину}    glVertex3f(0,0,1000); //позиция первой вершины
glColor3f(0,0,0.6); {раскрасим вторую вершину}    glVertex3f(0,0,-1000); //позиция второй вершины
glEnd;

glBegin(GL_QUADS); //рисуем нижнюю плоскость
glColor3f(1,0,0);  glVertex3i(-1,1,-1); //первая вершина
glColor3f(1,0,0);  glVertex3f(1,1,-1); //вторая вершина
glColor3f(1,0,0);  glVertex3f(1,-1,-1); //третья вершина
glColor3f(1,0,0);  glVertex3f(-1,-1,-1); //четвёртая вершина
glEnd;

glBegin(GL_QUADS); //рисуем верхнюю плоскость
glColor3f(0,1,0);  glVertex3i(-1,1,1); //первая вершина
glColor3f(0,1,0);  glVertex3f(1,1,1); //вторая вершина
glColor3f(0,1,0);  glVertex3f(1,-1,1); //третья вершина
glColor3f(0,1,0);  glVertex3f(-1,-1,1); //четвёртая вершина
glEnd;

glBegin(GL_QUADS); //рисуем первую боковую плоскость
glColor3f(0,0,1);  glVertex3i(1,1,-1); //первая вершина
glColor3f(0,0,1);  glVertex3f(1,-1,-1); //вторая вершина
glColor3f(0,0,1);  glVertex3f(1,-1,1); //третья вершина
glColor3f(0,0,1);  glVertex3f(1,1,1); //четвёртая вершина
glEnd;

glBegin(GL_QUADS); //рисуем вторую боковую плоскость
glColor3f(0,1,1);  glVertex3i(1,1,-1); //первая вершина
glColor3f(0,1,1);  glVertex3f(-1,1,-1); //вторая вершина
glColor3f(0,1,1);  glVertex3f(-1,1,1); //третья вершина
glColor3f(0,1,1);  glVertex3f(1,1,1); //четвёртая вершина
glEnd;

glBegin(GL_QUADS); //рисуем третью боковую плоскость
glColor3f(0,1,1);  glVertex3i(1,1,1); //первая вершина
glColor3f(0,1,1);  glVertex3f(1,1,1); //вторая вершина
glColor3f(0,1,1);  glVertex3f(1,1,1); //третья вершина
glColor3f(0,1,1);  glVertex3f(1,1,1); //четвёртая вершина
glEnd;

SwapBuffers(Canvas.Handle);
end;

procedure TForm1.FormResize(Sender: TObject);
begin
  glViewport(0, 0, ClientWidth, ClientHeight); //выделяем область куда будет выводиться наш буфер
  glMatrixMode ( GL_PROJECTION ); //переходим в матрицу проекции
  glLoadIdentity;  //Сбрасываем текущую матрицу
  glFrustum ( -1 , 1 , -1 , 1 , 1.25 , 100.0 ); //Область видимости
  glMatrixMode ( GL_MODELVIEW ); //переходим в модельную матрицу
  glLoadIdentity;//Сбрасываем текущую матрицу
  gluLookAt(Dist,Dist,Dist,0,0,0,0,0,1);  //позиция наблюдателя
  InvalidateRect ( Handle,nil,False );  //перерисовка формы
end;

end.
